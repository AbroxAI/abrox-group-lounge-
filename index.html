<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Abrox ‚Äì Private Lounge</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#1c1f26">
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/lucide@latest"></script>
<script src="emoji-pack.js" defer></script>
<script>
tailwind.config = {
  theme: {
    extend: {
      colors: {
        bg:'#1c1f26',
        panel:'#232833',
        border:'#343a4a',
        muted:'#a0a6b5',
        accent:'#6bdba7',
        bubble:'#262b38',
        bubbleOut:'#2b3242',
        send:'#3b82f6'
      }
    }
  }
}
</script>
<style>
*{box-sizing:border-box}

/* ================= HEADER ================= */
.header{background:#232833;border-bottom:1px solid #343a4a}

/* members / typing rows */
.members-row,.typing-row{
  padding:0 16px;height:22px;font-size:12px;
  display:flex;align-items:center
}
.members-row{color:#a0a6b5}
.typing-row{gap:8px;font-weight:500;color:#6bdba7;display:none}
.typing-row.active{display:flex}
.members-row.hidden{display:none}

/* typing dots */
.typing-dots{display:flex;gap:3px}
.typing-dots span{
  width:4px;height:4px;border-radius:999px;
  background:#6bdba7;opacity:.25;
  animation:blink 1.4s infinite both
}
.typing-dots span:nth-child(2){animation-delay:.15s}
.typing-dots span:nth-child(3){animation-delay:.3s}
@keyframes blink{0%,80%,100%{opacity:.25}40%{opacity:1}}

/* ================= CHAT ================= */
.msg{display:flex;gap:8px;margin-bottom:8px;align-items:flex-end;transition:transform .18s ease, opacity .18s ease}
.msg.out{justify-content:flex-end}
.grouped{margin-top:-6px}

.avatar{width:42px;height:42px;border-radius:999px;object-fit:cover}
.msg.grouped .avatar{visibility:hidden}

.bubble{
  max-width:74%;
  padding:10px 16px;
  font-size:14px;
  line-height:1.5;
  position:relative;
  box-shadow:0 2px 8px rgba(0,0,0,.18)
}
.msg.in .bubble{
  background:#262b38;
  border-radius:10px 20px 20px 10px
}
.msg.in .bubble::before{
  content:'';
  position:absolute;
  left:-8px;bottom:14px;
  width:12px;height:12px;
  background:#262b38;
  transform:rotate(45deg)
}
.msg.out .bubble{
  background:#2b3242;
  border:1px solid #343a4a;
  border-radius:20px 10px 10px 20px
}
.msg.out .bubble::after{
  content:'';
  position:absolute;
  right:-8px;bottom:14px;
  width:12px;height:12px;
  background:#2b3242;
  transform:rotate(45deg)
}
.grouped.in .bubble::before,
.grouped.out .bubble::after{display:none}

/* meta */
.sender{
  font-size:12px;font-weight:600;color:#6bdba7;
  margin-bottom:6px;display:flex;gap:8px;align-items:center
}
.time{
  font-size:10px;
  opacity:.55;
  margin-top:6px;
  display:flex;
  gap:6px;
  justify-content:flex-end;
  align-items:center
}

/* ================= DATE PILLS ================= */
.date-pill{
  position:sticky;
  top:8px;
  z-index:10;
  margin:16px auto;
  width:max-content;
  padding:4px 12px;
  border-radius:999px;
  background:rgba(0,0,0,.35);
  backdrop-filter:blur(6px);
  font-size:11px;
  opacity:0;
  animation:fadeDate .35s ease forwards;
}
@keyframes fadeDate{to{opacity:1}}

/* ================= REPLY / REACTIONS ================= */
.reply-preview{
  font-size:11px;opacity:.9;
  border-left:3px solid #6bdba7;
  padding-left:8px;margin-bottom:6px;
  cursor:pointer;background:rgba(0,0,0,.06);border-radius:6px;padding-top:6px;padding-bottom:6px
}
.reply-preview .snippet{opacity:.85;font-size:13px;margin-top:4px}
.reactions{display:flex;gap:4px;margin-top:4px}
.reaction{
  background:#1c1f26;border:1px solid #343a4a;
  border-radius:999px;padding:1px 6px;
  font-size:11px;cursor:pointer
}

/* ================= PIN ================= */
.pinned-banner{
  background:#232833;border-bottom:1px solid #343a4a;
  padding:8px 16px;font-size:13px;
  display:flex;gap:8px;align-items:center;cursor:pointer
}
.pinned-banner.hidden{display:none}

/* ================= INPUT / WAVEFORM ================= */
.footer-wrap{position:relative;background:transparent}
.input-shell{
  display:flex;
  align-items:center;
  background:#1c1f26;
  border-radius:999px;
  padding:10px 12px;
  gap:8px;
  width:100%;
  position:relative;
  overflow:hidden;
}

.input-shell.recording{
  padding:10px 14px;
}

#waveform{
  flex:1;
  height:36px;
  display:none;
  margin-left:6px;
  margin-right:6px;
}
.input-shell.recording #waveform{
  display:block;
}
.input-shell.recording input{
  display:none;
}

.input-shell .mic-lock-icon{
  position:absolute;left:12px;top:50%;transform:translateY(-50%);display:none;align-items:center;gap:6px
}
.input-shell.locked .mic-lock-icon{display:flex}

/* reply preview container */
#replyPreviewContainer{padding:6px 0 6px 0}

/* cancel overlay */
.recording-cancel-overlay{
  position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none;font-weight:600;opacity:0;transition:opacity .12s ease;color:#ff6b6b
}
.recording-cancel-overlay.visible{opacity:1;pointer-events:auto}

/* ================= UNREAD ================= */
#unreadBtn{
  position:fixed;bottom:110px;left:50%;
  transform:translateX(-50%);
  background:#3b82f6;
  color:#fff;
  padding:6px 14px;
  border-radius:999px;
  font-size:12px;
  display:none;
  z-index:40
}

/* ================= SIDEBAR ================= */
#sidebar{transition:transform .25s ease}
#memberSearch{
  width:100%;
  padding:6px 10px;
  border-radius:999px;
  background:#1c1f26;
  border:1px solid #343a4a;
  font-size:12px;
  outline:none;
}

.role-pill{font-size:10px;padding:2px 6px;border-radius:999px}
.role-pill.admin{background:#ef4444;color:white}
.role-pill.mod{background:#7c3aed;color:white}
.verified-bubble i{width:12px;height:12px}

section{-webkit-overflow-scrolling:touch}
</style>
</head>
<body class="bg-bg text-white h-[100dvh] overflow-hidden">
<div class="flex h-full">  <main class="flex flex-col flex-1 border-r border-border">  <header class="header">
  <div class="flex items-center justify-between px-4 py-3">
    <div class="flex gap-3 items-center">
      <img src="assets/logo.png" class="w-9 h-9 rounded">
      <div>
        <div class="text-sm font-semibold">Abrox Binary Bot ‚Äì Private Lounge</div>
        <div class="flex items-center gap-1 text-xs text-muted">
          <i data-lucide="lock" class="w-3 h-3"></i>
          <span>Private Group</span>
        </div>
      </div>
    </div>
    <button id="membersBtn"><i data-lucide="users"></i></button>
  </div>    <div class="members-row" id="membersRow">
    Members: <strong id="memberCount">4,872</strong>
    <span class="mx-2">‚Ä¢</span>
    Online: <strong id="onlineCount">0</strong>
  </div>    <div class="typing-row" id="typingRow">
    <div class="typing-dots"><span></span><span></span><span></span></div>
    <span id="typingText"></span>
  </div>    <div class="px-4 text-xs text-muted pb-1">
    Demo discussion ¬∑ Verification required
  </div>
</header>  <div id="pinnedBanner" class="pinned-banner hidden" role="button" tabindex="0">
  <i data-lucide="pin" id="pinnedIcon"></i>
  <span id="pinnedText" class="flex-1 truncate"></span>
  <button id="unpinBtn"><i data-lucide="x"></i></button>
</div>  <section id="chat" class="flex-1 overflow-y-auto px-4 py-4">
  <div class="text-center text-muted text-sm mb-4">
    üìå <strong>Group Rules</strong><br>
    New members are read-only until verified<br>
    Admins DM individually<br>
    No screenshots in chat<br>
    Ignore unsolicited messages
  </div>
</section>  <button id="unreadBtn">‚¨á New messages</button>

<footer class="bg-panel border-t border-border px-4 py-3 footer-wrap">
  <div id="replyPreviewContainer" class="px-2"></div>
  <div class="recording-cancel-overlay" id="cancelOverlay">Swipe left to cancel</div>
  <div class="flex items-center gap-2">
    <button id="emojiBtn"><i data-lucide="smile"></i></button>
    <div class="input-shell" id="inputShell" aria-live="polite">
      <div class="mic-lock-icon" aria-hidden="true"><i data-lucide="lock"></i><span class="text-xs text-muted">Recording locked</span></div>
      <input id="input" class="flex-1 bg-transparent outline-none text-sm" placeholder="Message" autocomplete="off">
      <canvas id="waveform"></canvas>
    </div>

    <div class="flex items-center gap-2 ml-auto">
      <button id="mediaBtn"><i data-lucide="paperclip"></i></button>
      <button id="micBtn" aria-pressed="false"><i data-lucide="mic"></i></button>
      <button id="send" class="hidden text-send"><i data-lucide="send"></i></button>
    </div>
  </div>
</footer>  </main>  <aside id="sidebar" class="fixed right-0 top-0 w-72 h-full bg-panel border-l border-border translate-x-full z-50 flex flex-col">
  <div class="p-4 border-b border-border flex justify-between">
    <strong>Members</strong>
    <button id="closeSidebar"><i data-lucide="x"></i></button>
  </div>    <div class="p-3">
    <input id="memberSearch" placeholder="Search members‚Ä¶">
  </div>    <div id="memberList" class="flex-1 overflow-y-auto p-3 space-y-3"></div>
</aside>  <input type="file" id="fileInput" class="hidden">
<script>
/* ================= INIT ================= */
requestAnimationFrame(()=>lucide.createIcons());  /* ================= CORE */
const chat = document.getElementById('chat');
const input = document.getElementById('input');
const send = document.getElementById('send');
const emojiBtn = document.getElementById('emojiBtn');
const mediaBtn = document.getElementById('mediaBtn');
const micBtn = document.getElementById('micBtn');
const fileInput = document.getElementById('fileInput');
const unreadBtn = document.getElementById('unreadBtn');
const inputShell = document.getElementById('inputShell');
const micLockIcon = inputShell.querySelector('.mic-lock-icon');
const replyPreviewContainer = document.getElementById('replyPreviewContainer');
const cancelOverlay = document.getElementById('cancelOverlay');

const membersRow = document.getElementById('membersRow');
const typingRow = document.getElementById('typingRow');
const typingText = document.getElementById('typingText');
const onlineCountEl = document.getElementById('onlineCount');
const memberCountEl = document.getElementById('memberCount');

const sidebar = document.getElementById('sidebar');
const membersBtn = document.getElementById('membersBtn');
const closeSidebar = document.getElementById('closeSidebar');
const memberList = document.getElementById('memberList');
const memberSearch = document.getElementById('memberSearch');

const pinnedBanner = document.getElementById('pinnedBanner');
const pinnedText = document.getElementById('pinnedText');
const pinnedIcon = document.getElementById('pinnedIcon');
const unpinBtn = document.getElementById('unpinBtn');

/* ================= STATE ================= */
const ADMIN = { name:'Profit Hunter üåê', role:'ADMIN', avatar:'assets/admin.jpg', lastActive:Date.now() };
const MOD   = { name:'Kitty Star ‚≠ê', role:'MOD', avatar:'assets/mod.jpg', lastActive:Date.now()-60000 };

let members = [ADMIN, MOD];
// For sidebar display we keep a small sample list; counts and presence are simulated separately to avoid huge arrays.
let sampleMembers = [ADMIN, MOD];
for(let i=0;i<40;i++){
  sampleMembers.push({
    name: `Member_${i+1}`,
    role: Math.random()<0.02 ? 'ADMIN' : Math.random()<0.06 ? 'MOD' : 'VERIFIED',
    avatar: `https://randomuser.me/api/portraits/${i%2===0?'men':'women'}/${(i+10)%90}.jpg`,
    lastActive: Date.now() - Math.floor(Math.random()*600000)
  });
}

// Persistent member count (realistic growth, stored)
let persistedMemberCount = Number(localStorage.getItem('member_count') || 4872);
localStorage.setItem('member_count', String(persistedMemberCount));
let virtualOnlineCount = Number(localStorage.getItem('virtual_online') || 75);

// pinned message state (id stored)
// pinned text stored separately for robust restore
let pinnedMessageId = localStorage.getItem('pinned_message_id') || null;

// reply state
let replyTo = null;

/* ================= MEMBERS / PRESENCE ================= */
function saveMemberCount(){
  localStorage.setItem('member_count', String(persistedMemberCount));
}
function saveVirtualOnline(){
  localStorage.setItem('virtual_online', String(virtualOnlineCount));
}

function tickMemberGrowth(){
  // slow organic growth: sometimes increments 0-2 members every 20-90s
  if(Math.random() < 0.35){
    persistedMemberCount += Math.random() < 0.7 ? 1 : 2;
    saveMemberCount();
  }
}
setInterval(tickMemberGrowth, 30000 + Math.random()*60000);

// online count drifts (60-120) with slight random changes; persisted across reloads
function driftOnlineCount(){
  const drift = Math.floor((Math.random()-0.5)*8);
  virtualOnlineCount = Math.max(60, Math.min(120, virtualOnlineCount + drift));
  saveVirtualOnline();
  onlineCountEl.textContent = virtualOnlineCount;
}
setInterval(driftOnlineCount, 5000);
onlineCountEl.textContent = virtualOnlineCount;
memberCountEl.textContent = persistedMemberCount.toLocaleString();

// render sidebar sample members (mixed states)
function presenceOf(m){
  const d = Date.now() - m.lastActive;
  if(d < 90000) return 'online';
  if(d < 300000) return 'idle';
  return 'offline';
}
function renderMembers(){
  const q = (memberSearch.value||'').toLowerCase();
  memberList.innerHTML = '';
  sampleMembers.filter(m=>m.name.toLowerCase().includes(q)).slice(0,80).forEach(m=>{
    const p = presenceOf(m);
    const color = p==='online'?'bg-green-500':p==='idle'?'bg-yellow-400':'bg-gray-500';
    memberList.innerHTML += `
      <div class="flex gap-3 items-center">
        <div class="relative">
          <img src="${m.avatar}" class="w-10 h-10 rounded-full">
          <span class="absolute bottom-0 right-0 w-3 h-3 rounded-full ${color}"></span>
        </div>
        <div>
          <div class="text-sm">${m.name}</div>
          <span class="text-[10px] px-2 py-[1px] rounded-full ${ m.role==='ADMIN'?'bg-red-600': m.role==='MOD'?'bg-purple-600':'bg-green-600' }">${m.role}</span>
        </div>
      </div>`;
  });
}
setInterval(renderMembers, 3000);
memberSearch.oninput = renderMembers;
renderMembers();

/* ================= TYPING SIMULATION (1-3 users) ================= */
function typingSimulation(){
  // Occasionally show 1-3 typers. Not spammy.
  if(Math.random() > 0.6) return (typingRow.classList.remove('active'), membersRow.classList.remove('hidden'));
  // choose 1-3 distinct online sample members
  const onlinePool = sampleMembers.filter(m=>presenceOf(m) === 'online' && m.role!=='ADMIN');
  if(onlinePool.length === 0) return;
  const count = Math.min(3, 1 + Math.floor(Math.random()*3));
  const picks = [];
  for(let i=0;i<count && onlinePool.length;i++){
    const idx = Math.floor(Math.random()*onlinePool.length);
    picks.push(onlinePool.splice(idx,1)[0]);
  }
  if(picks.length === 1){
    typingText.textContent = `${picks[0].name} is typing‚Ä¶`;
  } else if(picks.length === 2){
    typingText.textContent = `${picks[0].name} and ${picks[1].name} are typing‚Ä¶`;
  } else {
    typingText.textContent = `3 people are typing‚Ä¶`;
  }
  typingRow.classList.add('active');
  membersRow.classList.add('hidden');
  setTimeout(()=>{ typingRow.classList.remove('active'); membersRow.classList.remove('hidden'); }, 900 + Math.random()*2200);
}
setInterval(typingSimulation, 3500);

/* ================= MESSAGE CORE & SEEN RECEIPTS ================= */
let lastSender=null, lastTime=0, lastDate='';
let unread=0;
const seenCache = {}; // msgId -> seen count

function seenCount(msg){
  if(!seenCache[msg.id]){
    // start at 75, then slowly tick up
    seenCache[msg.id] = 75 + Math.floor(Math.random()*6);
    const grow = setInterval(()=>{
      // increment by 0-2 occasionally
      if(Math.random() < 0.6) seenCache[msg.id] += Math.floor(Math.random()*2);
      const cap = Math.max(virtualOnlineCount, 75);
      if(seenCache[msg.id] >= cap) { seenCache[msg.id] = cap; clearInterval(grow); }
      const el = document.querySelector(`[data-id="${msg.id}"] .time`);
      if(el) {
        const span = el.querySelector('span');
        if(span) span.textContent = seenCache[msg.id];
      }
    }, 2000 + Math.random()*3000);
  }
  return seenCache[msg.id];
}

function postMessage(m){
  m.id = crypto.randomUUID();
  m.time = Date.now();
  // small incoming delay for realism
  setTimeout(()=> renderMessage(m, true), m.out ? 10 : (200 + Math.random()*450));
}

function dateLabel(d){
  const today = new Date();
  const diff = Math.floor((today - d)/(86400000));
  if(diff===0) return 'Today';
  if(diff===1) return 'Yesterday';
  return d.toDateString();
}

function scrollToMessageId(id){
  const el = document.querySelector(`[data-id="${id}"]`);
  if(el){
    el.scrollIntoView({behavior:'smooth', block:'center'});
    // flash
    el.style.transition = 'box-shadow .4s ease';
    el.style.boxShadow = '0 0 0 3px rgba(107,219,167,0.12)';
    setTimeout(()=>{ el.style.boxShadow = ''; }, 800);
  }
}

function renderMessage(m,isNew){
  const d = new Date(m.time);

  if(d.toDateString() !== lastDate){
    const pill = document.createElement('div');
    pill.className = 'date-pill';
    pill.textContent = dateLabel(d);
    chat.appendChild(pill);
    lastDate = d.toDateString();
  }

  const grouped = lastSender===m.name && (m.time-lastTime)<120000;
  lastSender = m.name;
  lastTime = m.time;

  const badge =
    m.role==='ADMIN'?'<span class="role-pill admin">ADMIN</span>':
    m.role==='MOD'?'<span class="role-pill mod">MOD</span>':
    '<span class="verified-bubble"><i data-lucide="gem"></i></span>';

  const el = document.createElement('div');
  el.className = `msg ${m.out? 'out' : 'in'} ${grouped? 'grouped' : ''}`;
  el.dataset.id = m.id;

  const avatarHtml = !m.out ? `<img class="avatar" src="${sampleMembers.find(x=>x.name===m.name)?.avatar||''}" alt="${m.name}">` : '';

  el.innerHTML = `
    ${avatarHtml}
    <div class="bubble">
      ${m.replyTo?`<div class="reply-preview" data-reply-to="${m.replyTo}"><div class="sender-sn">${m.replyMeta?m.replyMeta.sender:'Reply'}</div><div class="snippet">${m.replyMeta?m.replyMeta.snippet:''}</div></div>`:''}
      ${!grouped && !m.out?`<div class="sender">${m.name} ${badge}</div>`:''}
      <div class="content">${m.text}</div>
      <div class="time">
        <i data-lucide="eye" class="w-3 h-3"></i>
        <span>${m.out? seenCount(m) : '¬∑'}</span>
        ¬∑ ${d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}
      </div>
    </div>
  `;
  chat.appendChild(el);
  lucide.createIcons();

  // add long-press/context menu handling for pin/reply on this message
  attachMessageInteractions(el, m);

  if(isNew && chat.scrollTop+chat.clientHeight < chat.scrollHeight-60){
    unread++;
    unreadBtn.textContent = `‚¨á ${unread} new messages`;
    unreadBtn.style.display = 'block';
  } else {
    chat.scrollTop = chat.scrollHeight;
  }
}

/* interactions: improved long-press (cancellable on move) and context menu */
function attachMessageInteractions(domEl, msg){
  // right-click menu
  domEl.addEventListener('contextmenu', (ev) => {
    ev.preventDefault();
    showContextMenuAt(ev.clientX, ev.clientY, msg, domEl);
  });

  // long-press (touch) with cancellation on move
  let touchTimer = null;
  let startX = 0, startY = 0;
  domEl.addEventListener('touchstart', (ev) => {
    if(touchTimer) { clearTimeout(touchTimer); touchTimer = null; }
    const t = ev.touches[0];
    startX = t.clientX; startY = t.clientY;
    touchTimer = setTimeout(()=> {
      showContextMenuAt(t.clientX, t.clientY, msg, domEl);
      touchTimer = null;
    }, 600);
  }, {passive:true});

  domEl.addEventListener('touchmove', (ev) => {
    if(!touchTimer) return;
    const t = ev.touches[0];
    const dx = Math.abs(t.clientX - startX);
    const dy = Math.abs(t.clientY - startY);
    if(dx > 10 || dy > 10) { clearTimeout(touchTimer); touchTimer = null; } // cancel long-press during swipe
  }, {passive:true});

  domEl.addEventListener('touchend', ()=>{ if(touchTimer) { clearTimeout(touchTimer); touchTimer = null; }});
}

/* context menu creation with viewport clamping */
function showContextMenuAt(x,y,msg,anchorEl){
  document.querySelectorAll('.context-menu').forEach(m=>m.remove());
  const menu = document.createElement('div');
  menu.className = 'context-menu';
  menu.style.position = 'fixed';
  menu.style.left = `${x}px`;
  menu.style.top = `${y}px`;
  menu.style.background = '#11121a';
  menu.style.border = '1px solid #343a4a';
  menu.style.padding = '6px';
  menu.style.borderRadius = '8px';
  menu.style.zIndex = 9999;
  menu.innerHTML = `
    <div class="menu-item" data-action="reply" style="padding:6px 10px;cursor:pointer">Reply</div>
    <div class="menu-item" data-action="pin" style="padding:6px 10px;cursor:pointer">Pin</div>
  `;
  document.body.appendChild(menu);

  // clamp so menu never goes off-screen
  const rect = menu.getBoundingClientRect();
  let left = x, top = y;
  if(left + rect.width > window.innerWidth - 8) left = window.innerWidth - rect.width - 8;
  if(top + rect.height > window.innerHeight - 8) top = window.innerHeight - rect.height - 8;
  menu.style.left = `${Math.max(8, left)}px`;
  menu.style.top = `${Math.max(8, top)}px`;

  menu.querySelector('[data-action="reply"]').addEventListener('click', ()=>{
    document.querySelectorAll('.context-menu').forEach(m=>m.remove());
    setReplyTo(msg.id);
  });
  menu.querySelector('[data-action="pin"]').addEventListener('click', ()=>{
    document.querySelectorAll('.context-menu').forEach(m=>m.remove());
    pinMessage(msg.id);
  });

  // close on outside tap
  setTimeout(()=> {
    document.addEventListener('click', function closer(e){
      if(!menu.contains(e.target)) { menu.remove(); document.removeEventListener('click', closer); }
    });
  }, 10);
}

/* ================= PIN MESSAGE (store id + text for robust restore) ================= */
function pinMessage(id){
  const target = document.querySelector(`[data-id="${id}"]`);
  let msgContent = 'Pinned message';
  if(target && target.querySelector('.content')){
    msgContent = target.querySelector('.content').textContent;
  } else {
    // try to find stored content from rendered messages
    const existingText = localStorage.getItem('pinned_message_text');
    if(existingText) msgContent = existingText;
  }
  // persist both id and text
  pinnedMessageId = id;
  localStorage.setItem('pinned_message_id', id);
  localStorage.setItem('pinned_message_text', msgContent);
  pinnedText.textContent = msgContent.length > 120 ? msgContent.slice(0,117) + '...' : msgContent;
  pinnedBanner.classList.remove('hidden');
  lucide.createIcons();
}
function unpinMessage(){
  pinnedMessageId = null;
  localStorage.removeItem('pinned_message_id');
  localStorage.removeItem('pinned_message_text');
  pinnedText.textContent = '';
  pinnedBanner.classList.add('hidden');
}
pinnedBanner.addEventListener('click', ()=>{
  if(pinnedMessageId) scrollToMessageId(pinnedMessageId);
});
unpinBtn.addEventListener('click', (e)=>{ e.stopPropagation(); unpinMessage(); });

// restore pinned on load: show stored text immediately and try to resolve id later
const storedPinnedText = localStorage.getItem('pinned_message_text');
if(storedPinnedText){
  pinnedText.textContent = storedPinnedText;
  pinnedBanner.classList.remove('hidden');
}
if(pinnedMessageId){
  // try to find pinned message element for up to 10s
  const tryScroll = setInterval(()=>{
    if(document.querySelector(`[data-id="${pinnedMessageId}"]`)){
      clearInterval(tryScroll);
      lucide.createIcons();
    }
  }, 500);
  setTimeout(()=> clearInterval(tryScroll), 10000);
}

/* ================= REPLY PREVIEW UI ================= */
function setReplyTo(msgId){
  const target = document.querySelector(`[data-id="${msgId}"]`);
  if(!target) return;
  replyTo = msgId;
  // build preview: sender + snippet
  const senderEl = target.querySelector('.sender');
  const sender = senderEl ? senderEl.textContent : (target.querySelector('.content') ? target.querySelector('.content').textContent.slice(0,18) : 'Message');
  const snippet = target.querySelector('.content') ? target.querySelector('.content').textContent.slice(0,120) : '';
  replyPreviewContainer.innerHTML = `<div class="reply-preview" id="replyPreview"><div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">${sender}</div><div style="font-size:11px;opacity:.65;cursor:pointer" id="clearReply">‚úï</div></div><div class="snippet">${snippet}</div></div>`;
  // jump to original on preview tap
  document.getElementById('replyPreview').addEventListener('click', ()=> scrollToMessageId(msgId));
  document.getElementById('clearReply').addEventListener('click', (e)=> { e.stopPropagation(); clearReply(); });
  input.focus();
}
function clearReply(){
  replyTo = null;
  replyPreviewContainer.innerHTML = '';
}

/* ================= SEND HANDLING (text + voice send while locked) ================= */
send.addEventListener('click', (ev) => {
  // If we're recording and locked, this acts as "send voice now"
  if(recording && locked){
    // stopMic triggers mediaRecorder.onstop which posts the audio message
    stopMic(true); // pass true to indicate send (not cancel)
    return;
  }
  // otherwise send text if present
  if(input.value.trim()){
    postMessage({ name:'You', role:'VERIFIED', text: input.value.trim(), out:true, replyTo, replyMeta: getReplyMeta(replyTo) });
    clearReply();
    input.value = '';
    send.classList.add('hidden');
    mediaBtn.classList.remove('hidden');
    micBtn.classList.remove('hidden');
    input.focus();
  }
});

/* helper: collect reply metadata for preview in message */
function getReplyMeta(msgId){
  if(!msgId) return null;
  const target = document.querySelector(`[data-id="${msgId}"]`);
  if(!target) return null;
  return {
    sender: target.querySelector('.sender') ? target.querySelector('.sender').textContent : 'Message',
    snippet: target.querySelector('.content') ? target.querySelector('.content').textContent.slice(0,120) : ''
  };
}

/* ================= EMOJI / MEDIA ================= */
emojiBtn.onclick = ()=>window.EmojiPack && EmojiPack.openPicker(input);
mediaBtn.onclick = ()=>fileInput.click();
fileInput.onchange = e=>{
  if(!e.target.files.length) return;
  const f = e.target.files[0];
  const url = URL.createObjectURL(f);
  postMessage({
    name:'You',
    role:'VERIFIED',
    text: f.type.startsWith('image/') ? `<img src="${url}" class="rounded-lg max-w-full">` : `üìé ${f.name}`,
    out:true,
    replyTo,
    replyMeta: getReplyMeta(replyTo)
  });
  clearReply();
  fileInput.value='';
};

/* ================= MIC + WAVEFORM (WhatsApp behaviour) ================= */
const canvas = document.getElementById('waveform');
const ctx = canvas.getContext('2d');

let audioCtx, analyser, micStream, mediaRecorder;
let waveAnim = null, locked=false, recording=false, canceled=false;
let chunks=[];

// waveform sizing: fill inputShell minus padding & show centered
function resizeWave(){
  const style = getComputedStyle(inputShell);
  const padLeft = parseInt(style.paddingLeft || 12);
  const padRight = parseInt(style.paddingRight || 12);
  const total = inputShell.clientWidth - padLeft - padRight - 40; // reserve mic icon area
  canvas.width = Math.max(180, total);
  canvas.height = Math.max(28, inputShell.clientHeight - 6);
}
window.addEventListener('resize', resizeWave);
resizeWave();

function drawWave(){
  if(!analyser) return;
  const bufferLength = analyser.fftSize;
  const data = new Uint8Array(bufferLength);
  analyser.getByteTimeDomainData(data);

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.strokeStyle = '#3b82f6';

  const slice = canvas.width / data.length;
  let x=0;
  for(let i=0;i<data.length;i++){
    const v = data[i]/128;
    const y = (v*canvas.height)/2;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    x+=slice;
  }
  ctx.stroke();

  waveAnim = requestAnimationFrame(drawWave);
}

async function startMic(){
  try{
    // reset states
    canceled = false;
    chunks = [];
    recording = true;
    locked = false;
    micBtn.setAttribute('aria-pressed','true');
    inputShell.classList.add('recording');
    inputShell.classList.remove('locked');
    micLockIcon.querySelector('span').textContent = 'Recording locked';

    // hide text input and show waveform
    input.style.display = 'none';
    canvas.style.display = 'block';
    cancelOverlay.classList.remove('visible');
    cancelOverlay.textContent = 'Swipe left to cancel';

    micStream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;

    const source = audioCtx.createMediaStreamSource(micStream);
    source.connect(analyser);

    // mime fallback: try webm, then ogg, else default
    let mime = 'audio/webm';
    try {
      if(!MediaRecorder.isTypeSupported(mime)){
        mime = MediaRecorder.isTypeSupported('audio/ogg') ? 'audio/ogg' : '';
      }
    } catch (e) { mime = ''; }
    try {
      mediaRecorder = mime ? new MediaRecorder(micStream, {mimeType: mime}) : new MediaRecorder(micStream);
    } catch (err) {
      console.error('MediaRecorder creation failed', err);
      cancelOverlay.classList.add('visible');
      cancelOverlay.textContent = 'Recording not supported';
      recording = false;
      try{ micStream.getTracks().forEach(t=>t.stop()); }catch(e){}
      input.style.display='block';
      canvas.style.display='none';
      inputShell.classList.remove('recording');
      micBtn.setAttribute('aria-pressed','false');
      return;
    }

    mediaRecorder.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    mediaRecorder.onstop = ()=>{
      cancelAnimationFrame(waveAnim);
      // restore UI
      canvas.style.display = 'none';
      input.style.display = 'block';
      inputShell.classList.remove('recording');
      inputShell.classList.remove('locked');
      micBtn.style.display = '';
      micBtn.setAttribute('aria-pressed','false');

      // if canceled -> discard
      if(canceled){
        chunks = [];
        try{ micStream.getTracks().forEach(t => t.stop()); }catch(e){}
        if(audioCtx && audioCtx.state !== 'closed') audioCtx.close();
        return;
      }

      if(chunks.length){
        const blob = new Blob(chunks,{type: mime || 'audio/webm'});
        const url = URL.createObjectURL(blob);
        postMessage({
          name:'You',
          role:'VERIFIED',
          text:`<audio controls src="${url}"></audio>`,
          out:true,
          replyTo,
          replyMeta: getReplyMeta(replyTo)
        });
      }
      chunks=[];
      try{ micStream.getTracks().forEach(t => t.stop()); }catch(e){}
      if(audioCtx && audioCtx.state !== 'closed') audioCtx.close();
      // finalize
      recording = false;
      locked = false;
      canceled = false;
      clearReply();
    };

    mediaRecorder.start();
    drawWave();
  }catch(err){
    console.error('Mic start error', err);
    recording = false;
    input.style.display = 'block';
    canvas.style.display = 'none';
    inputShell.classList.remove('recording');
    micBtn.setAttribute('aria-pressed','false');
    cancelOverlay.classList.add('visible');
    cancelOverlay.textContent = 'Allow mic access';
    setTimeout(()=> cancelOverlay.classList.remove('visible'), 2500);
  }
}

function stopMic(forceSend=false){
  if(!recording) return;
  // if user requested forceSend, ensure we don't treat as canceled
  if(forceSend) canceled = false;
  if(canceled && mediaRecorder && mediaRecorder.state !== 'inactive'){
    mediaRecorder.stop();
    return;
  }
  if(mediaRecorder && mediaRecorder.state !== 'inactive'){
    mediaRecorder.stop();
  }
}

function cancelRecording(){
  if(!recording) return;
  canceled = true;
  if(mediaRecorder && mediaRecorder.state !== 'inactive'){
    mediaRecorder.stop();
  } else {
    try{ micStream.getTracks().forEach(t=>t.stop()); }catch(e){}
    recording = false; canceled = false; locked = false;
    input.style.display='block'; canvas.style.display='none'; inputShell.classList.remove('recording');
    micBtn.setAttribute('aria-pressed','false');
  }
}

/* gesture handling */
let startY = 0, startX = 0, lastTouchId = null;
function startGesture(e){
  const touch = e.touches ? e.touches[0] : e;
  startY = touch.clientY;
  startX = touch.clientX;
  lastTouchId = touch.identifier !== undefined ? touch.identifier : null;
  canceled = false;
  cancelOverlay.classList.remove('visible');
  cancelOverlay.textContent = 'Swipe left to cancel';
}

// start / stop handling for touch and mouse
micBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); startGesture(e); startMic(); }, {passive:false});
micBtn.addEventListener('mousedown', (e)=>{ if(e.button!==0) return; startGesture(e); startMic(); });

micBtn.addEventListener('touchmove', (e)=> {
  if(!recording) return;
  const t = Array.from(e.touches).find(t=> t.identifier === lastTouchId) || e.touches[0];
  const dy = startY - t.clientY;
  const dx = t.clientX - startX;

  // swipe up to lock
  if(dy > 60 && !locked && !canceled){
    locked = true;
    inputShell.classList.add('locked');
    micLockIcon.querySelector('span').textContent = 'Recording locked';
    send.classList.remove('hidden'); // show send button when locked
    micBtn.style.display = 'none'; // hide mic button when locked
    cancelOverlay.classList.remove('visible');
  }

  // swipe left to cancel
  if(dx < -40 && !canceled && !locked){
    canceled = true;
    cancelOverlay.classList.add('visible');
    cancelOverlay.textContent = 'Release to cancel';
  } else if(!canceled){
    cancelOverlay.classList.remove('visible');
    cancelOverlay.textContent = 'Swipe left to cancel';
  }
}, {passive:true});

micBtn.addEventListener('touchend', (e)=> {
  // if cancel was active and user releases -> cancel recording
  if(canceled){
    cancelRecording();
    cancelOverlay.classList.remove('visible');
    return;
  }
  if(locked){
    // remain recording; user must tap send to send, or tap mic to cancel in other UI flows
    recording = true;
    return;
  }
  // else normal release -> stop & auto-send
  if(recording && !locked){
    stopMic();
  }
}, {passive:false});

micBtn.addEventListener('mouseup', (e)=>{
  if(canceled){
    cancelRecording();
    cancelOverlay.classList.remove('visible');
    return;
  }
  if(locked){
    return;
  }
  if(recording && !locked){
    stopMic();
  }
});

/* visibility change cleanup (avoid stuck media) */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    if(recording){
      cancelRecording();
    }
  }
});

/* ================= SWIPE-TO-REPLY (touch on message) ================= */
let swipeX = 0, swipingEl = null;
chat.addEventListener('touchstart', e =>{
  const msg = e.target.closest('.msg');
  if(!msg) return;
  swipeX = e.touches[0].clientX;
  swipingEl = msg;
});
chat.addEventListener('touchmove', e =>{
  if(!swipingEl) return;
  const dx = e.touches[0].clientX - swipeX;
  if(dx > 12 && dx < 160){
    swipingEl.style.transform = `translateX(${Math.min(dx/6,20)}px)`;
    swipingEl.style.opacity = `${Math.max(0.65, 1 - dx/400)}`;
  }
});
chat.addEventListener('touchend', e =>{
  if(!swipingEl) return;
  const finalDx = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX - swipeX : 0;
  swipingEl.style.transform = '';
  swipingEl.style.opacity = '';
  if(finalDx > 70){
    // trigger reply mode on that message
    const id = swipingEl.dataset.id;
    setReplyTo(id);
  }
  swipingEl = null;
});

/* ================= TAP/CLOSE CONTEXTS ================= */
document.addEventListener('click', e=>{
  document.querySelectorAll('.context-menu').forEach(m=>m.remove());
});

/* ================= SIDEBAR TOGGLE ================= */
membersBtn.onclick = ()=>sidebar.classList.toggle('translate-x-full');
closeSidebar.onclick = ()=>sidebar.classList.add('translate-x-full');

/* ================= JOIN / SAMPLE MESSAGES ================= */
if(!localStorage.getItem('joined')){
  localStorage.setItem('joined','1');
  setTimeout(()=>{
    postMessage({ name:'You', role:'VERIFIED', text:'üëã You joined the group', out:false });
  },400);
}

/* bootstrap sample messages */
setTimeout(()=>{
  postMessage({name:ADMIN.name,role:'ADMIN',text:'Welcome everyone üëã',out:false});
  postMessage({name:MOD.name,role:'MOD',text:'Please follow the rules.',out:false});
  // sample content
  postMessage({name:'Member_1',role:'VERIFIED',text:'Hey, excited to be here!',out:false});
  postMessage({name:'Member_2',role:'VERIFIED',text:'Does anyone share indicators?',out:false});
},600);

/* unread button behaviour */
unreadBtn.addEventListener('click', ()=>{
  chat.scrollTop = chat.scrollHeight;
  unread = 0;
  unreadBtn.style.display = 'none';
});

/* ================= BOOT SAFETY ================= */
setTimeout(()=>{
  if(chat.children.length<=1){
    postMessage({
      name:ADMIN.name,
      role:'ADMIN',
      text:'Chat initialized successfully.',
      out:false
    });
  }
  // re-init lucide icons after rendering
  lucide.createIcons();
}, 900);

/* ================= MESSAGE INTERACTIONS: tap reply-preview inside messages to jump ================= */
chat.addEventListener('click', (e)=>{
  const rp = e.target.closest('.reply-preview');
  if(rp && rp.dataset && rp.dataset.replyTo){
    const id = rp.dataset.replyTo;
    scrollToMessageId(id);
  }
});

/* ================= SAFETY / HOUSEKEEPING ================= */
window.addEventListener('beforeunload', ()=>{
  try{ if(recording) cancelRecording(); }catch(e){}
});

/* expose small helper for debugging */
window._abrox = {
  postMessage,
  renderMessage,
  pinMessage,
  unpinMessage,
  setReplyTo: (id)=> setReplyTo(id)
};
</script>
</body>
</html>
